<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>&Iacute;ndice</h2>
<p>&nbsp;</p>
<p><img class="pluginslug" src="/plugin_helper.php?plugin=toc&amp;depth=4" alt="" /></p>
<p>&nbsp;</p>
<p>Implementaci&oacute;n de un motor de expresiones regulares (en adelante, regexp) usando Java 6.0</p>
<p>&nbsp;</p>
<p>La estrategia de dise&ntilde;o elegida ha sido la construcci&oacute;n de un Aut&oacute;mata finito no determinista, a partir de la regexp, y su posterior conversi&oacute;n a Aut&oacute;mata finito determinista para la ejecuci&oacute;n de la misma.&nbsp;</p>
<p>Para construir los aut&oacute;matas se parte de un &aacute;rbol sint&aacute;ctico construido tras un an&aacute;lisis l&eacute;xico-sint&aacute;ctico de la regexp. El an&aacute;lisis de la sintaxis se realiza mediante la implementaci&oacute;n de un parser descendente-predictivo-recursivo.</p>
<p>&nbsp;</p>
<p>La aplicaci&oacute;n est&aacute; implementada con Java 6.0 y se puede construir v&iacute;a maven. Se incluyen algunos test de prueba. El proyecto s&oacute;lo tiene tres dependencias:</p>
<p>&nbsp;</p>
<p>* sfl4j-log4j 1.7.7 para logging. Principalmente mostrar en texto la estructura de los aut&oacute;matas</p>
<p>* Apache Commons IO 2.4, usado s&oacute;lo en los tests.&nbsp;</p>
<p>* JUnit 4.4 para tests.</p>
<p>&nbsp;</p>
<p><a href="/w/file/83777218/regex-engine.zip">Descargar proyecto.</a></p>
<p>&nbsp;</p>
<p>Para construirlo, ejecutar</p>
<p>&nbsp;</p>
<pre>mvn package
</pre>
<p>&nbsp;</p>
<p>Las im&aacute;genes utilizadass en este art&iacute;culo han sido generadas usando el lenguaje DOT de Graphviz. Las clases que representan los aut&oacute;matas y el &aacute;rbol sint&aacute;ctico tienen m&eacute;todos toString() que generan estos datos.</p>
<p>Para ver este salida, establecer el nivel a DEBUG en el Log ra&iacute;z configurado en el fichero fichero log4j.properties.</p>
<p>Se puede renderizar estos gr&aacute;ficos con la herramienta dot, inclu&iacute;da en el paquete graphviz, o con esta <a href="http://graphviz-dev.appspot.com/">herramienta online.</a></p>
<p>&nbsp;</p>
<p>No se profundizar&aacute; mucho en la teor&iacute;a de aut&oacute;matas y lenguajes formales, s&oacute;lo se cubrir&aacute; lo necesario para entender la arquitectura. Para ampliar informaci&oacute;n, nada mejor que las siguientes referencias:</p>
<p>&nbsp;</p>
<ul>
<li><span style="font-size: 13px; line-height: 1.5em;">Compiladores: principios, t&eacute;cnicas y herramientas	(aka "El libro del drag&oacute;n") (Alfred V. Aho, Monica S. Lam, Ravi Sethi y Jeffrey D. Ullman)&nbsp;</span><span style="font-size: 13px; line-height: 1.5em;">ISBN 978-970-26-1133-2&nbsp;</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Introducci&oacute;n a la teor&iacute;a de aut&oacute;matas, lenguajes y computaci&oacute;n. (John E. Hopcroft, Rajeev Motwani and Jeffrey D.)&nbsp;</span><span style="font-size: 13px; line-height: 1.5em;">ISBN 978-84-7829-088-8</span></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Caracter&iacute;sticas regexp soportadas.</h2>
<p>&nbsp;</p>
<table style="width: 40%;" border="0">
<tbody>
<tr>
<td colspan="2">Caracteres&nbsp;&nbsp;</td>
</tr>
<tr>
<td style="width: 50px;">x</td>
<td>El car&aacute;cter x&nbsp;</td>
</tr>
<tr>
<td>\t&nbsp;</td>
<td>Tabulaci&oacute;n.</td>
</tr>
<tr>
<td>\s&nbsp;</td>
<td>Espacio en blanco.&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<table style="width: 40%;" border="0">
<tbody>
<tr>
<td colspan="2">Clases de caracteres.&nbsp;&nbsp;</td>
</tr>
<tr>
<td style="width: 50px;">[abc]&nbsp;&nbsp;</td>
<td>Uno de los caracteres entre corchetes.&nbsp;</td>
</tr>
<tr>
<td>[a-z]&nbsp;</td>
<td>Un rango de caracteres desde la a hasta la z (ambos inclu&iacute;dos)&nbsp;</td>
</tr>
<tr>
<td>[a-zA-Z]&nbsp;</td>
<td>Un rango de caracteres desde la a hasta la z o desde la A hasta la Z (ambos inclu&iacute;dos)&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table style="width: 40%;" border="0">
<tbody>
<tr>
<td colspan="2">Cuantificadores.&nbsp;&nbsp;</td>
</tr>
<tr>
<td style="width: 50px;">*&nbsp;</td>
<td>Cero o m&aacute;s veces.&nbsp;</td>
</tr>
<tr>
<td>+&nbsp;</td>
<td>Una o m&aacute;s veces.&nbsp;</td>
</tr>
<tr>
<td>?&nbsp;</td>
<td>Cero o una vez.&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table style="width: 40%;" border="0">
<tbody>
<tr>
<td colspan="2">Operadores&nbsp;&nbsp;</td>
</tr>
<tr>
<td style="width: 50px;">|&nbsp;</td>
<td>Alternativa OR&nbsp;</td>
</tr>
<tr>
<td>(X)&nbsp;</td>
<td>Agrupaci&oacute;n (cambio de orden de precedencia)&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table style="width: 40%;" border="0">
<tbody>
<tr>
<td colspan="2">Caracteres especiales&nbsp;&nbsp;</td>
</tr>
<tr>
<td style="width: 50px;">\x&nbsp;</td>
<td>Escapa car&aacute;cter x&nbsp;</td>
</tr>
<tr>
<td>.&nbsp;</td>
<td>Cualquier car&aacute;cter imprimible (Unicode)&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Orden de precedencia (de mayor a menor)</p>
<p>&nbsp;</p>
<ol>
<li><span style="font-size: 13px; line-height: 1.5em;">(EXPR) Agrupaci&oacute;n de expresi&oacute;nx</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">x (Car&aacute;cter x)</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Cuantificador (*, + , ?)&nbsp;</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Operador OR</span></li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Uso</h2>
<h2><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></h2>
<p>Las expresiones regulares ser&aacute;n especificadas en un <em>String</em> y debe ser compiladas antes de poder usarlas. La regexp se ejecutar&aacute; sobre un buffer de char que contiene el texto.</p>
<p>&nbsp;</p>
<p>El resultado de la b&uacute;squeda puede ser devuelto a un objeto tipo <em>RegexMatchResult</em> donde se almacenar&aacute;n las posiciones de comienzo y longitud de las coincidencias. Las posiciones son indexadas desde cero.</p>
<p>&nbsp;</p>
<p>El motor expone tres clases principales:</p>
<p>&nbsp;</p>
<ul>
<li><strong style="font-family: inherit; font-style: inherit; line-height: 1.5em;">RegexEngine</strong><span style="font-size: 13px; line-height: 1.5em;">. Clase principal. Se usar&aacute; su m&eacute;todo </span><em style="font-family: inherit; font-weight: inherit; line-height: 1.5em;">compile</em><span style="font-size: 13px; line-height: 1.5em;"> para obtener un objeto tipo Regex.</span></li>
<li><strong style="font-family: inherit; font-style: inherit; line-height: 1.5em;">Regex</strong><span style="font-size: 13px; line-height: 1.5em;">. Objeto que representa la expresi&oacute;n regular compilada. Se usar&aacute; su m&eacute;todo </span><em style="font-family: inherit; font-weight: inherit; line-height: 1.5em;">match</em><span style="font-size: 13px; line-height: 1.5em;"> para enfrentar la regexp a un texto. Retornar&aacute; <em>true</em> si ha encontrado alguna coincidencia. Opcionalmente puede recibir un objeto tipo </span><em style="font-family: inherit; font-weight: inherit; line-height: 1.5em;">RegexMatchResult</em><span style="font-size: 13px; line-height: 1.5em;"> con informaci&oacute;n sobre la coincidencia encontrada.&nbsp;</span></li>
<li><strong style="font-family: inherit; font-style: inherit; line-height: 1.5em;">RegexMatchResult</strong><span style="font-size: 13px; line-height: 1.5em;">. Objecto con informaci&oacute;n sobre posici&oacute;n y longitud de la coincidencia encontrada. Adem&aacute;s, este objeto tiene un atributo llamado </span><em style="font-family: inherit; font-weight: inherit; line-height: 1.5em;">position</em><span style="font-size: 13px; line-height: 1.5em;"> que indica al motor desde qu&eacute; posici&oacute;n del texto debe comenzar la b&uacute;squeda.</span></li>
</ul>
<p>&nbsp;</p>
<p>Es importante resaltar que el comportamiento de este motor es tipo ''eager'', es decir, en caso de expresiones tipo OR, como <em>(a|b)</em>, el motor probar&aacute; la primera de las expresiones alternadas y, en caso de no cumplirse, reinicir&aacute; el estado y probar&aacute; la alternativa desde la &uacute;ltima posici&oacute;n del texto que hay asido v&aacute;lida (retorna al principio si no se ha encontrado ningina coincidencia antes)</p>
<p>&nbsp;</p>
<p>Cuando se encuentra una coincidencia, el an&aacute;lisis se detiene y el m&eacute;todo <em>match</em> retornar&aacute; true. Para continuar se debe especificar en el objeto <em>RegexMatchResult</em> la posici&oacute;n donde comenzar de nuevo y volver a llamar con esa nueva posici&oacute;n a <em>match.</em></p>
<p><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></p>
<h3>Ejemplo de uso. Obtener n&uacute;meros en un texto:</h3>
<p>&nbsp;</p>
<pre>package es.chathispano.canalprogramacion.regexengine.tests;

import java.text.MessageFormat;

import es.chathispano.canalprogramacion.regexengine.Regex;
import es.chathispano.canalprogramacion.regexengine.RegexEngine;
import es.chathispano.canalprogramacion.regexengine.RegexMatchResult;

public class Example {

&nbsp;&nbsp;&nbsp; public static void main(String[] args) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// texto a comprobar
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String text = "kjdsk65sdksdk78odla98dasdf90dsakdsj";

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// buscar n&uacute;meros en el texo
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Regex regex = RegexEngine.compile("[0-9]+");

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// almacenar resultados de cada b&uacute;squeda
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RegexMatchResult regexMatchResult = new RegexMatchResult();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// preparar input
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char buffer[] = text.toCharArray();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// meintras encuentre n&uacute;meros...
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (regex.match(buffer, regexMatchResult)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int start = regexMatchResult.getMatchStartPosition();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int length = regexMatchResult.getMatchLength();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(MessageFormat.format("Encontrada coincidencia en posicion {0}. Texto que coincide: {1}",
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start, text.substring(start, start + length)));

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// comenzar desde la &uacute;ltima coincidencia
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regexMatchResult.setPosition(start + length);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp; }
}

</pre>
<p>Salida (posiciones desde columna cero):</p>
<p>&nbsp;</p>
<p><img class="pluginslug" src="/plugin_helper.php?plugin=external&amp;name=x&amp;code=%3Cpre%3E%0AEncontrada+coincidencia+en+posici%C3%B3n+5.+Texto+que+coincide%3A+65%0AEncontrada+coincidencia+en+posici%C3%B3n+13.+Texto+que+coincide%3A+78%0AEncontrada+coincidencia+en+posici%C3%B3n+19.+Texto+que+coincide%3A+98%0AEncontrada+coincidencia+en+posici%C3%B3n+26.+Texto+que+coincide%3A+90%0A%3C%2Fpre%3E" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Arquitectura.</h2>
<p>&nbsp;</p>
<h3>Vistazo general.</h3>
<p>&nbsp;</p>
<p>El n&uacute;cleo central de la aplicaci&oacute;n reside en construir un aut&oacute;mata finito determinista, el cual es ejecutado por el objeto Regex. Recordar que un lenguaje regular, que es el tipo de lenguaje que describen las expresiones regulares, puede ser reconocido por un aut&oacute;mata finito determinista.</p>
<p>&nbsp;</p>
<p>Diferenciamos dos partes a la hora de describir la aplicaci&oacute;n:</p>
<p>&nbsp;</p>
<ol>
<li><span style="font-size: 13px;">Compilaci&oacute;n regexp.</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Ejecuci&oacute;n de la regexp contra un texto.</span></li>
</ol>
<p>&nbsp;</p>
<p>Dada una regexp como<em> java.lang.String</em> se proceder&aacute; a seguir los siguentes pasos hasta su compilaci&oacute;n en un objeto de tipo <em>Regex</em></p>
<p>&nbsp;</p>
<ol>
<li><span style="font-size: 13px; line-height: 1.5em;">An&aacute;lisis l&eacute;xico de la regexp, obteniendo las piezas sint&aacute;cticas (tokens) m&iacute;nimas.</span></li>
<li><span style="line-height: 1.5em;">An&aacute;lisis sint&aacute;ctico de la regexp. Revisa que la regexp est&eacute; bien&nbsp;</span>construida<span style="line-height: 1.5em;">&nbsp;y construye el &aacute;rbol de nodos sint&aacute;cticos.</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Construcci&oacute;n de aut&oacute;mata no determinista (AFND) a partir del &aacute;rbol sint&aacute;ctico. Para ello se siguen los criterios de Thompson. En esta parte tambi&eacute;n se realiza cierto an&aacute;lisis sem&aacute;ntico, sobre todo en lo que concierne a los rangos.</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Conversi&oacute;n del aut&oacute;mata no determinista en uno determinista (AFD) Se usa el Algoritmo de Construcci&oacute;n de Subconjuntos.</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Se almacena el aut&oacute;mata determinista en una instancia del objeto <em>Regex</em>.</span></li>
</ol>
<p>&nbsp;</p>
<p>Dada una regexp compilada en un objeto <em>Regex,</em>&nbsp;se realizan los siguientes pasos en su ejecuci&oacute;n contra un texto:</p>
<p>&nbsp;</p>
<ol>
<li><span style="font-size: 13px; line-height: 1.5em;">El aut&oacute;mata comenzar&aacute; desde su estado inicial. Mientras haya transiciones en el estado actual, el motor intentar&aacute; ejecutar una por cada car&aacute;cter del b&uacute;fer de entrada; as&iacute; hasta que el aut&oacute;mata llegue a un estado de aceptaci&oacute;n o sin transiciones.</span></li>
<li><span style="line-height: 1.5em;">Si llega a un estado de&nbsp;</span>aceptaci&oacute;n<span style="line-height: 1.5em;">&nbsp;pero hay m&aacute;s transiciones a otros estados, el motor seguir&aacute; leyendo caracteres para ejecutar esas transiciones.</span></li>
</ol>
<p><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></p>
<ul>
<li><span style="font-size: 13px; line-height: 1.5em;">Se considera que hay coincidencia y se detiene el an&aacute;lisis cuando:</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">El aut&oacute;mata est&aacute; en un estado de aceptaci&oacute;n y no hay m&aacute;s transiciones.</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">El texto ha terminado y el aut&oacute;mata est&aacute; en un estado de aceptaci&oacute;n (esto sucede cuando se procesa una regexp con cuantificador asterisco)</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">Habiendo m&aacute;s transiciones en un estado de aceptaci&oacute;n y el car&aacute;cter que llega de entrada no cumple ninguna.</span></li>
</ul>
<p>&nbsp;</p>
<p>Diagrama que presenta las fases de la compilaci&oacute;n de la regexp.</p>
<p>&nbsp;</p>
<p><img id="pbImage988795" style="border: 0px;" src="/f/rexgen_arch.png" alt="Diagrama que presenta las fases de la compilaci&oacute;n de la regexp." width="220" height="528" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>En la siguiente imagen se puede observar el aut&oacute;mata finito determinista que el motor construye para ejecutar la regexp&nbsp;</p>
<p>&nbsp;</p>
<pre>&lt;[a-z]+:?[a-z]+[0-9]?\\s*(/&gt;|&gt;) (1)
 </pre>
<p>que reconoce etiquetas html</p>
<p>&nbsp;</p>
<p><img id="pbImage371851" style="border: 0px;" src="/f/rexgen_afd1.png" alt="AFD de la expresi&oacute;n regular &lt;[a-z]+:?[a-z]+[0-9]?\\s*(/&gt;|&gt;)" width="800" height="232" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>Parseo de la expresi&oacute;n regular.</h3>
<p>&nbsp;</p>
<p>Se entiende por parseo de la regexp la tarea de analizar la expresi&oacute;n regular para compilarla.</p>
<p>&nbsp;</p>
<h4>Gram&aacute;tica.</h4>
<p>&nbsp;</p>
<p>La especificaci&oacute;n de nuestro lenguaje regexp no puede hacerse mediante un lenguaje regular debido a que existen producciones de este tipo:</p>
<p>&nbsp;</p>
<pre>A -&gt; xAy</pre>
<p>&nbsp;</p>
<p>O la necesidad de mantener las parejas de par&eacute;ntesis o corchetes.&nbsp;</p>
<p><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></p>
<p>Se necesita entonces una gram&aacute;tica libre de contexto. Se especifica la gram&aacute;tica a usar en notaci&oacute;n EBNF.</p>
<p>&nbsp;</p>
<pre>1.&nbsp;&nbsp;&nbsp;&nbsp; &lt;regexp&gt; ::= &lt;quantified_expression&gt; { &lt;quantified_expression&gt; } &lt;regex&gt;
2.&nbsp;&nbsp;&nbsp;&nbsp; &lt;regex&gt; ::= '|' &lt;regexp&gt; 
3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | palabra_vacia
4.&nbsp;&nbsp;&nbsp;&nbsp; &lt;quantified_expression&gt; ::= &lt;expression&gt; [ &lt;quantifier&gt; ]
5.&nbsp;&nbsp;&nbsp;&nbsp; &lt;expression&gt; ::=&nbsp; &lt;selector&gt; 
6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | '(' &lt;regexp&gt; ')' 
7.&nbsp;&nbsp;&nbsp;&nbsp; &lt;selector&gt; ::= &lt;symbol&gt; 
8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;range&gt;
9.&nbsp;&nbsp;&nbsp;&nbsp; &lt;range&gt; ::= '[' &lt;char_range&gt; ']'
10.&nbsp;&nbsp;&nbsp; &lt;char_range&gt; ::=&nbsp; &lt;symbol&gt; 
11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;escape_char&gt; { &lt;char_range&gt; }
12.&nbsp;&nbsp;&nbsp; &lt;symbol&gt; ::= &lt;char&gt; 
13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;escape&gt;
14..21 &lt;char&gt; ::= Caracteres imprimibles excepto '(' | ')' | '*' | '+' | '?' | '[' | '\' | '|'
22..30 &lt;escape_char&gt; ::=&nbsp;&nbsp;&nbsp; '(' | ')' | '*' | '+' | '?' | '[' | '\' | '|' 
31..37 &lt;escape&gt; ::= '\' &lt;escape_char&gt; | 's' | 't' | '-' | ']' | '^' | '.'
38.&nbsp;&nbsp;&nbsp; &lt;quantifier&gt; ::= '*'
39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | '+' 
40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | '?'</pre>
<p>&nbsp;</p>
<p>Esta gram&aacute;tica cumple la condici&oacute;n LL(1) Recordemos que, grosso modo, una gram&aacute;tica LL(1) es aquella que permite elegir una producci&oacute;n determinada con s&oacute;lo leer un token por adelantado. Para otros tipos de gram&aacute;ticas LL(k) para k &gt; 1, la implementaci&oacute;n del analizador sint&aacute;ctico se complicar&iacute;a considerablemente.</p>
<p>&nbsp;</p>
<p>Siguiendo esta gram&aacute;tica, se ha establecido que un selector es cualquier s&iacute;mbolo que permita seleccionar texto. Por ejemplo, un car&aacute;cter de la regexp o un rango son selectores.&nbsp;</p>
<p>Una expresi&oacute;n es o un selector o una agrupaci&oacute;n (lo que va entre par&eacute;ntesis) y una agrupaci&oacute;n puede contener a otras regexp.</p>
<p>Una expresi&oacute;n cuantificada es una expresi&oacute;n seguida, opcionalmente, de un cuantificador. La regexp estar&aacute; formada por una o m&aacute;s expresiones cuantificadas y opcionalmente unidas por el caracter '|' (alternativa u OR)</p>
<p>Una rango estar&aacute; formado por una sucesi&oacute;n de uno o m&aacute;s s&iacute;mbolos entre los caracteres '[' y ']'</p>
<p>&nbsp;</p>
<p>Se observa que en la especificaci&oacute;n de rangos (producci&oacute;n 9) no se ha establecido nada sobre los guiones ni la posici&oacute;n de estos. Tal estrategia es debida a que se he dejado la interpretaci&oacute;n de los rangos en la parte de la construcci&oacute;n del aut&oacute;mata finito no determinista, es decir, los rangos se establecen mediante un an&aacute;lisis sem&aacute;ntico. Esto facilita construcciones de este tipo:</p>
<p><span style="font-size: 13px;">&nbsp;</span></p>
<p>[[az\]]<br /><br />que son v&aacute;lidas en la implementaci&oacute;n PCRE. Se observa que '[' no se ha escapado, pero ']' s&iacute;. Sint&aacute;cticamente resulta m&aacute;s complicado analizar estas diferencias que hacerlo mediante an&aacute;lisis sem&aacute;ntico.</p>
<p>&nbsp;</p>
<h4>An&aacute;lisis l&eacute;xico de la expresi&oacute;n regular</h4>
<p>&nbsp;</p>
<p>La misi&oacute;n del analizador l&eacute;xico es agrupar el texto de entrada en piezas l&eacute;xicas o s&iacute;mbolos indivisibles (com&uacute;nmente llamadas tokens) que ser&aacute;n enviadas al analizador sint&aacute;ctico.</p>
<p>&nbsp;</p>
<p>Hay que tener en cuenta que en en esta implementaci&oacute;n los espacios y tabuladores no forman parte del lenguaje regexp en s&iacute;, por lo que esos caracteres son ignorados. En esta implementaci&oacute;n no se permite el car&aacute;cter de retorno de l&iacute;nea '\n'.</p>
<p>&nbsp;</p>
<p>De esta gram&aacute;tica podemos elegir los tokens que constituir&aacute;n el l&eacute;xico. Antes de identificarlos, establecemos qu&eacute; caracteres son reservados. Esto podemos deducirlo de las producciones 14 a 21</p>
<pre>'(' &nbsp;')' &nbsp;'*' &nbsp;'+' &nbsp;'?' &nbsp;'[' &nbsp;'\' &nbsp;'|'
</pre>
<p>&nbsp;</p>
<p>Estos caracteres ser&aacute;n tratados como tokens espec&iacute;ficos, cada uno con su ID:</p>
<p>&nbsp;</p>
<pre>'(' -&gt; L_PARENTHESIS&nbsp;</pre>
<pre>')' -&gt; R_PARENTHESIS</pre>
<pre>'*' &nbsp;'+' &nbsp;'?' -&gt; QUANTIFIER &nbsp;&amp;nbsp;</pre>
<pre>'[' -&gt; R_BRACKET</pre>
<pre>'\' -&gt; ESCAPE</pre>
<pre>'|' -&gt; PIPE</pre>
<p>&nbsp;</p>
<p>Se crear&aacute; el <strong>enum</strong> <em>Token</em> con los valores de estos tokens l&eacute;xicos:</p>
<p>&nbsp;</p>
<pre>public enum Token {

&nbsp;&nbsp;&nbsp; /* tokens */
&nbsp;&nbsp;&nbsp; CHAR, L_PARENTHESIS, R_PARENTHESIS, L_BRACKET, PIPE, QUANTIFIER, ESCAPE,

&nbsp;&nbsp;&nbsp; /* elementos sint&aacute;cticos */
&nbsp;&nbsp;&nbsp; REGEX, SELECTOR, RANGE, QUANTIFIED_EXPR, GROUP, EXPRESSION, CHAR_RANGE, REGEXP,
&nbsp;&nbsp;&nbsp; /* elementos auxiliares */
&nbsp;&nbsp;&nbsp; ROOT,
}

</pre>
<p>De momento no atenderemos a los tokens sint&aacute;cticos.</p>
<p>&nbsp;</p>
<p>El analizador sint&aacute;ctico mantendr&aacute; una referencia a un analizador l&eacute;xico, el cual utilizar&aacute; para solicitar tokens.&nbsp;</p>
<p>El analizador l&eacute;xico debe exponer un procedimiento que devuelva al analizador sint&aacute;ctico los tokens desde la entrada:</p>
<p>&nbsp;</p>
<p>Para codificar un analizador l&eacute;xico, se lee una serie de caracteres (es conveniente leer al menos tantos como longitud de caracteres tenga el token m&aacute;s largo) y comprobar car&aacute;cter a car&aacute;cter hasta que encontremos que coincide con un token determinado.&nbsp;</p>
<p>&nbsp;</p>
<pre>leerTokenSiguiente &lt;strong&gt;return&lt;/strong&gt; token</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer = leerCarateresEntrada(minimo);</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>string</strong> tokenActual = nulo;</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>char</strong> caracter = leerCaracter(buffer);
 </pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>case</strong> 'car&aacute;cter por el que comience X'&amp;nbsp;</pre>
<pre>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenActual = leerBuffer(longitud token X)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.. resto de casos</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;ningun caso:</strong></pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errorLexico(posicion);&amp;nbsp;</pre>
<pre><strong>fin</strong> leerTokenSiguiente.
  
</pre>
<p>Este pseudoc&oacute;digo debe ser ejecutado cada vez que el analizador sint&aacute;ctico pida un token nuevo para comprobar la gram&aacute;tica.&nbsp;</p>
<p>En nuestro caso s&oacute;lo es necesario leer car&aacute;cter a car&aacute;cter sin necesidad de un b&uacute;fer intermedio, ya que todos los tokens de la gram&aacute;tica tienen longitud uno.&nbsp;</p>
<p>&nbsp;</p>
<p>El m&eacute;todo que devuelve los tokens al analizador sint&aacute;ctico queda:</p>
<p>&nbsp;</p>
<pre>public boolean readToken() throws LexerException {
&nbsp;&nbsp; &nbsp;boolean charRead = readCharacter();
&nbsp;&nbsp; &nbsp;if (charRead) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; switch (character) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '[':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = Token.L_BRACKET;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenValue = "[";
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '(':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = Token.L_PARENTHESIS;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenValue = "(";
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case ')':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = Token.R_PARENTHESIS;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenValue = ")";
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '+':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '*':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '?':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = Token.QUANTIFIER;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenValue = String.valueOf(character);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '|':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = Token.PIPE;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tokenValue = "|";
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; case '\\':
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verifyEscapeCharacters();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (isValidChar(character)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; token = Token.CHAR;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; tokenValue = String.valueOf(character);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; lexError("Car&aacute;cter no v&aacute;lido");
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;return charRead;
}</pre>
<p><span style="font-size: 13px;">&nbsp;</span></p>
<p>Se observa que si llega un car&aacute;cter '\' necesariamente el car&aacute;cter siguiente ha de ser soportado para el escape. Esto lo comprueba el m&eacute;todo:</p>
<p>&nbsp;</p>
<pre>&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Detectada secuencia de escape. Verificar que el siguiente caracter
&nbsp;&nbsp;&nbsp;&nbsp; * pertenece al conjunto de caracteres que pueden escaparse.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; private void verifyEscapeCharacters() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (readCharacter()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int charIndex = findEscapedChar(character);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (charIndex &gt;= 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = Token.ESCAPE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tokenValue = String.valueOf(escape_chars_value[charIndex]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lexError("Car&aacute;cter " + character + " no forma parte de los caracteres de escape.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lexError("Se esperaba " + Arrays.toString(escape_chars));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
</pre>
<p><span style="font-size: 13px;">&nbsp;</span></p>
<p>Donde los caracteres de escape permitidos han sido definidos <strong>de forma ordenada</strong> en un array, que es el que usa el m&eacute;todo <em>findEscapeChar</em></p>
<p>&nbsp;</p>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// caracteres de escape permitidos (ordenados)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private char[] escape_chars =&nbsp; { '(', ')', '*', '+', '-', '.', '?', '[', '\\', ']', '^' ,'s', 't', '|' };

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// valor de los caracteres de escape (ordenados)
&nbsp;&nbsp;&nbsp;&nbsp; private char[] escape_chars_value = { '(', ')', '*', '+', '-', '.', '?', '[', '\\', ']', '^', ' ', '\t', '|' };

</pre>
<p>El analizador l&eacute;xico tambi&eacute;n debe ignorar convenientemente algunos caracteres si procede. En este caso los espacios y los tabuladores son ignorados. De esto se encarga el m&eacute;todo <em>readCharacter</em></p>
<p>&nbsp;</p>
<pre>// caracteres ignorados por el analizador lexico
private char[] ignoredChars = { '\t', ' ' };

private boolean readCharacter() {
&nbsp;&nbsp;&nbsp; boolean charRead = false;
&nbsp;&nbsp;&nbsp; while (!charRead &amp;&amp; index &lt; regex.length()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character = regex.charAt(index++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charRead = !isIgnoredChar(character);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; return charRead;
}

private boolean isIgnoredChar(char pCharacter) {
&nbsp;&nbsp; &nbsp;return (Arrays.binarySearch(ignoredChars, pCharacter) &gt;= 0);
}

</pre>
<h4><span style="font-size: 13px; line-height: 1.5em;">An&aacute;lisis sint&aacute;ctico de la expresi&oacute;n regular.</span></h4>
<p>&nbsp;</p>
<p>El analizador sint&aacute;ctico o Parser se encarga de verificar si la regexp est&aacute; correctamente formada. Para ello comprueba que la secuencia de tokens que va &nbsp;entregando el analizador l&eacute;xico cumple las especificaciones de la gram&aacute;tica que se ha definido.</p>
<p>&nbsp;</p>
<p>El parser implementado es del tipo descendente-predictivo-recursivo. Este tipo de parsers son muy comunes y f&aacute;ciles de implementar. Para poder codificarlos con facilidad es muy conveniente que la gram&aacute;tica dada sea LL(1), ya que leyendo s&oacute;lo un token por adelantado omitimos la necesidad de "volver hacia atr&aacute;s" en caso de que llegue un token que no corresponde con la producci&oacute;n que se analiza en ese momento.</p>
<p>&nbsp;</p>
<p>Este tipo de parsers definen un procedimiento por cada producci&oacute;n de la gram&aacute;tica. En cada procedimiento, se consumen los tokens en el orden que se ha establecido en dicha gram&aacute;tica. Si al consumir un token este no es el esperado, se lanza error sint&aacute;ctico.</p>
<p>&nbsp;</p>
<p>Analicemos un caso sencillo. Las producciones 5 y 6 de la gram&aacute;tica son:</p>
<p>7. &nbsp; &nbsp; &lt;selector&gt; ::= &lt;symbol&gt;&nbsp;</p>
<p>8.	 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;| &lt;range&gt;</p>
<p>&nbsp;</p>
<p>Para esta producci&oacute;n puede escribirse un m&eacute;todo como el siguiente:</p>
<p>&nbsp;</p>
<pre>private void prSelector() {

&nbsp;&nbsp; &nbsp;if (match(Token.CHAR, Token.ESCAPE)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; prSymbol();
&nbsp;&nbsp; &nbsp;} else if (token == Token.L_BRACKET) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; prRange();
&nbsp;&nbsp; &nbsp;}
}&nbsp;&nbsp;&nbsp; 
</pre>
<p>&nbsp;</p>
<p>Lo primero que observamos es que hay una sentencia if-else. Esto es debido a que la producci&oacute;n admite dos alternativas, como se puede observar. Esto implica que por cada alternativa de una producci&oacute;n en la gram&aacute;tica hay un sentencia condicional.&nbsp;</p>
<p>&nbsp;</p>
<p>E<span style="font-size: 13px; line-height: 1.5em;">sta sentecia decide si ir por una producci&oacute;n u otra, para ello se usa el m&eacute;todo </span><em style="font-family: inherit; font-weight: inherit; line-height: 1.5em;">match</em><span style="font-size: 13px; line-height: 1.5em;">, que comprueba si el valor del token le&iacute;do coincide con alguno de los que se pasan por par&aacute;metro.</span></p>
<p>&nbsp;</p>
<p>Se comprueba el token CHAR y el token ESCAPE porque precisamente la producci&oacute;n &lt;symbol&gt; est&aacute; formada por esos dos s&iacute;mbolos terminales:</p>
<p>&nbsp;</p>
<p>12. &nbsp; &nbsp;&lt;symbol&gt; ::= &lt;char&gt;&nbsp;</p>
<p>13. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;escape&gt;</p>
<p>&nbsp;</p>
<p>Viendo este comportamiento, podemos ver que estamos "analizando hacia abajo", ejecutando una verificaci&oacute;n del token actual y llamando recursivamente a la producci&oacute;n adecuada en funci&oacute;n del token le&iacute;do. De ah&iacute; el nombre de Parser descendente-predictivo-recursivo.</p>
<p>&nbsp;</p>
<p>La producci&oacute;n &lt;symbol&gt; tendr&aacute; su correspondiente m&eacute;todo que la representa:</p>
<p>&nbsp;</p>
<pre>private void prSymbol() {

&nbsp;&nbsp; &nbsp;if (match(Token.CHAR)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; consume(Token.CHAR);
&nbsp;&nbsp; &nbsp;} else if (match(Token.ESCAPE)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; consume(Token.ESCAPE);
&nbsp;&nbsp; &nbsp;}
}

</pre>
<p>Se comprueba que el m&eacute;todo tiene exactamente la misma estructura que la definici&oacute;n gramatical.</p>
<p>&nbsp;</p>
<p>Aqu&iacute; usamos un nuevo m&eacute;todo: &lt;em&gt;consume&lt;/em&gt;. Este m&eacute;todo verifica que el token actual sea el solicitado y luego lee el siguiente token, "consumiendo" el token actual. La diferencia con el m&eacute;todo <em>match</em> es precisamente que este &uacute;ltimo s&oacute;lo verifica el token actual, pero no lee el siguiente token.</p>
<p><em>&nbsp;</em></p>
<pre>private Token consume(String c) {
&nbsp;&nbsp; &nbsp;String tokenValue = lexicalAnalyzer.getTokenValue();
&nbsp;&nbsp; &nbsp;if (!c.equals(tokenValue)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; parseError(new String[] { c });
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;readNextToken();
&nbsp;&nbsp; &nbsp;return token;
}</pre>
<p>&nbsp;</p>
<p>En la l&iacute;nea 2 se puede ver c&oacute;mo se obtienen los tokens usando el analizador l&eacute;xico constru&iacute;do antes.</p>
<p>&nbsp;</p>
<p>Si en la gram&aacute;tica tenemos expresiones de tipo cuantificador como { &lt;produccion&gt; }, simplemente usamos un while.</p>
<p>&nbsp;</p>
<p>Analicemos el c&oacute;digo para la siguiente producci&oacute;n:</p>
<p>&nbsp;</p>
<p>1. &nbsp; &nbsp; &lt;regexp&gt; ::= &lt;quantified_expression&gt; { &lt;quantified_expression&gt; } &lt;regex&gt;</p>
<p>&nbsp;</p>
<p>La cual indica <em>"un &lt;quantified_expression&gt; repetido al menos una vez, seguido de una producci&oacute;n &lt;regex&gt;"</em></p>
<p>&nbsp;</p>
<p>Codificamos el m&eacute;todo seg&uacute;n esta especificaci&oacute;n gramatical:</p>
<p>&nbsp;</p>
<pre>private void prRegexp() {</pre>
&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// al menos un quantified_expression, luego es necesario verificar el primero. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Si el token que llega no corresponde a esa producci&oacute;n, es un error sint&aacute;ctico</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS)) {</pre>
<pre>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prQuantifiedExpression();</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</pre>
<pre>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parseError(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS);</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre>
&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// seguido de cero o m&aacute;s ({ &nbsp;&lt;quantified_expression&gt; })</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS)) {</pre>
<pre>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prQuantifiedExpression();</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ahora necesariamente ir&aacute; una producci&oacute;n regex()</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prRegex();</pre>
<pre>}</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Se muestra ahora el c&oacute;digo completo simplificado (sin la parte que crea el &aacute;rbol sint&aacute;ctico y omitiendo algunos m&eacute;todos de utilidad) del analizador sint&aacute;ctico:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre>public class Parser {

&nbsp;&nbsp;&nbsp; private LexicalAnalyzer lexicalAnalyzer;
&nbsp;&nbsp;&nbsp; private Token token;

&nbsp;&nbsp;&nbsp; public Parser(LexicalAnalyzer pLexicalAnalyzer) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lexicalAnalyzer = pLexicalAnalyzer;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void analyze() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // un s&iacute;mbolo adelantado
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; readNextToken();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (token == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new SyntaxException("Regex vac&iacute;a.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // entramos por la producci&oacute;n principal. A partir de ah&iacute; la recursi&oacute;n de
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // producciones consumir&aacute; los tokens.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prRegexp();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // an&aacute;lisis sint&aacute;ctico terminado.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no deber&iacute;a haber m&aacute;s tokens si el parseo ha sido correcto.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (token != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError("Expresi&oacute;n no balanceada.");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void prRegexp() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // al menos un quantified_expression. Es necesario verificar el primero
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // y si no hay, entonces es un error sint&aacute;ctico

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prQuantifiedExpression();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // seguido de cero o m&aacute;s.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET, Token.L_PARENTHESIS)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prQuantifiedExpression();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ahora un &lt;regex&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prRegex();
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void prRegex() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // si hay un pipe, necesariamente debe seguirle otra &lt;regexp&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.PIPE)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.PIPE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prRegexp();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // o palabra vacia.
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void prQuantifiedExpression() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // debe venir una expression
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prExpression();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // opcionalmente puede venir un cuantificador
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.QUANTIFIER)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.QUANTIFIER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private void prExpression() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prSelector();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (match(Token.L_PARENTHESIS)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.L_PARENTHESIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prRegexp(); // debe haber una regex entre los par&eacute;ntesis
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.R_PARENTHESIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private void prSelector() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.CHAR, Token.ESCAPE)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prSymbol();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (token == Token.L_BRACKET) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prRange();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private void prRange() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // debe haber un '['
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.L_BRACKET);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.ESCAPE, Token.CHAR)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prCharRange();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError(Token.CHAR, Token.ESCAPE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cerrar el rango
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume("]");
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private void prCharRange() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // evita un rango vacio. Aqui se ha hecho un peque&ntilde;o an&aacute;lisis sem&aacute;ntico.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lexicalAnalyzer.getTokenValue().equals("]")) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError(Token.CHAR, Token.ESCAPE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * El bucle while se puede consumir cualquier car&aacute;cter excepto ']'. El
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * l&eacute;xico enviar&aacute; tokens como L_PARENTHESIS o L_BRACKET si huiera
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * caracteres '(' y '[', pero en este caso se ignoran y se tratan como
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * CHAR.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!lexicalAnalyzer.getTokenValue().equals("]")) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(token);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private void prSymbol() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (match(Token.CHAR)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.CHAR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (match(Token.ESCAPE)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; consume(Token.ESCAPE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // fin de los m&eacute;todos asociados a las producciones.
&nbsp;&nbsp;&nbsp; private void readNextToken() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (lexicalAnalyzer.readToken()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = lexicalAnalyzer.getToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private boolean match(Token... pToken) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (Token t : pToken) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (token == t) { // uso == por null-safe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private Token consume(Token pToken) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!token.equals(pToken)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError(pToken);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; readNextToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return token;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private Token consume(String c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String tokenValue = lexicalAnalyzer.getTokenValue();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!c.equals(tokenValue)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseError(new String[] { c });
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; readNextToken();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return token;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void parseError(Token... tokens) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new SyntaxException(lexicalAnalyzer.getIndex(), tokens);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void parseError(String[] c) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new SyntaxException(lexicalAnalyzer.getIndex(), c);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private void parseError(String msg) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new SyntaxException(lexicalAnalyzer.getIndex(), msg);
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>&nbsp;</p>
<p>Realmente lo que se est&aacute; haciendo es simular un aut&oacute;mata a pila, que es el tipo de aut&oacute;mata que reconoce gram&aacute;ticas libres de contexto.</p>
<p>&nbsp;</p>
<h4>Generaci&oacute;n del &aacute;rbol sint&aacute;ctico</h4>
<p>&nbsp;</p>
<p>Construir el &aacute;rbol sint&aacute;ctico resulta muy sencillo en un analizador como el implementado, ya que al hacer las llamadas de forma descendente y recursiva, facilita considerablemente la tarea de manejar una estructura de datos de estructura arb&oacute;rea. De hecho, este &aacute;rbol sint&aacute;ctico no es m&aacute;s que un reflejo de todas las llamadas a cada una de las producciones que se van realizando en la ejecuci&oacute;n del analizador sint&aacute;ctico.</p>
<p>&nbsp;</p>
<p>Un nodo sint&aacute;ctico se representa con la siguiente clase:</p>
<p>&nbsp;</p>
<pre>public class ASTNode {

&nbsp;&nbsp;&nbsp; private String value = "";
&nbsp;&nbsp;&nbsp; private List&lt;ASTNode&gt; children;
&nbsp;&nbsp;&nbsp; private Token type;
&nbsp;&nbsp;&nbsp; private int positionInRegex;

&nbsp;&nbsp;&nbsp; public ASTNode(Token pType, int position) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = pType;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; children = new ArrayList&lt;ASTNode&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; positionInRegex = position;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public ASTNode(Token pType, String pValue) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type = pType;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = pValue;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public String getValue() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void setValue(String value) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.value = value;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public Iterable&lt;ASTNode&gt; getChildren() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Collections.unmodifiableList(children);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void addChild(ASTNode childNode) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; children.add(childNode);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public Token getType() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return type;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void setType(Token type) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public boolean isEmpty() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return children.isEmpty();
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public int getChildrenCount() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return children.size();
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public int getPositionInRegex() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return positionInRegex;
&nbsp;&nbsp;&nbsp; }

}</pre>
<p>&nbsp;</p>
<p>Para construirlo s&oacute;lo es necesario que cada m&eacute;todo que representa una producci&oacute;n construya su propio nodo y lo retorne. Al ser llamadas recursivas, los nodos se ir&aacute;n a&ntilde;adiendo al &aacute;rbol siguiendo el orden sint&aacute;ctico.</p>
<p>&nbsp;</p>
<p>Cada producci&oacute;n instanciar&aacute; un objeto ASTNode y le asignar&aacute; un token y su valor. Al mismo tiempo, a&ntilde;adir&aacute; como nodos hijos las llamadas a las producciones hijas que tenga.&nbsp;</p>
<p>&nbsp;</p>
<p>Por ejemplo, para la producci&oacute;n <em>&lt;expression&gt;</em></p>
<p>&nbsp;</p>
<pre>private ASTNode prExpression() {
&nbsp;&nbsp; &nbsp;ASTNode node = createNode(Token.EXPRESSION);
&nbsp;&nbsp; &nbsp;if (match(Token.CHAR, Token.ESCAPE, Token.L_BRACKET)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 
        ASTNode n = prSelector();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; addChildNode(node, n);

&nbsp;&nbsp; &nbsp;} else if (match(Token.L_PARENTHESIS)) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ASTNode nodeGroup = createNode(Token.GROUP);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; consume(Token.L_PARENTHESIS);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; ASTNode regex = prRegexp();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; consume(Token.R_PARENTHESIS);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; addChildNode(nodeGroup, regex);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; addChildNode(node, nodeGroup);
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;return node;
}</pre>
<p><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></p>
<p>Se observa c&oacute;mo cada producci&oacute;n retorna su propio nodo y estos se a&ntilde;aden como hijos al nodo actual.</p>
<p><span style="font-size: 13px; line-height: 1.5em;">&nbsp;</span></p>
<p>Para una regexp como<em> ab+, </em>se genera el siguiente &aacute;rbol sint&aacute;ctico:</p>
<p>&nbsp;</p>
<p><img id="pbImage981195" style="border: 0px none;" src="/f/rexgen_ast1.png" alt="" width="650" height="419" /></p>
<p>&nbsp;</p>
<h3><em>&nbsp;</em></h3>
<h3>Aut&oacute;matas.</h3>
<p>&nbsp;</p>
<h4>Estructura de datos para el aut&oacute;mata&nbsp;</h4>
<p>&nbsp;</p>
<p>Tomando como base que un aut&oacute;mata puede representarse mediante un grafo dirigido, la estructura elegida para representar este grafo ha sido utilizar listas de adyacencia. Esto consiste en guardar en cada nodo del grafo, que en este caso es un estado del aut&oacute;mata representado por la clase State, los punteros a los estados con los que est&aacute; conectado. Cada puntero al siguiente estado representa una transici&oacute;n al pr&oacute;ximo nodo o estado.</p>
<p>&nbsp;</p>
<pre>/**
&amp;nbsp;* Clase que representa un estado en un aut&oacute;mata finito.
&amp;nbsp;*/
public class State implements Comparable&amp;lt;State&amp;gt; {

&amp;nbsp;&amp;nbsp;&amp;nbsp; // conjunto de transiciones para este estado
&amp;nbsp;&amp;nbsp;&amp;nbsp; private List&amp;lt;Transition&amp;gt; transitions;

&amp;nbsp;&amp;nbsp;&amp;nbsp; // indica que es inicial
&amp;nbsp;&amp;nbsp;&amp;nbsp; private boolean initial = false;

&amp;nbsp;&amp;nbsp;&amp;nbsp; // indica que es final o de aceptaci&oacute;n
&amp;nbsp;&amp;nbsp;&amp;nbsp; private boolean end = false;

&amp;nbsp;&amp;nbsp;&amp;nbsp; private int id = -1;

&amp;nbsp;   // conecta un estado con otro por mediao de una transici&oacute;n.
&amp;nbsp;&amp;nbsp;&amp;nbsp; public void connect(Transition transition, State pState) {
&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transition.setNextState(pState);
&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transitions.add(transition);
&amp;nbsp;&amp;nbsp;&amp;nbsp; }
&amp;nbsp;}
&amp;nbsp;
 
</pre>
<p>Cada transici&oacute;n en s&iacute; misma es un objeto de la clase <em>Transition</em>, que representa el tipo de transici&oacute;n al siguiente estado.</p>
<p>&nbsp;</p>
<pre>public abstract class TransitionBase implements Transition, Comparable&lt;Transition&gt; {

&nbsp;&nbsp;&nbsp; private State nextState;
&nbsp;&nbsp;&nbsp; private String representation;

&nbsp;&nbsp;&nbsp; public State getNextState() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nextState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void setNextState(State nextState) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nextState = nextState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // conecta un estado con otro por mediao de una transici&oacute;n.
&nbsp;&nbsp;&nbsp; public void connect(Transition transition, State pState) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transition.setNextState(pState);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transitions.add(transition);
&nbsp;&nbsp;&nbsp; }
}

</pre>
<p>El objeto <em>Transition</em> es una interfaz que es implementada por una clase por cada tipo de transici&oacute;n:</p>
<p>&nbsp;</p>
<ul>
<li><span style="font-size: 13px; line-height: 1.5em;">TransitionEmpty. Representa una transici&oacute;n vac&iacute;a. Es fundamental para construir los AFND&nbsp;</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">TransitionExclude. Representa la transici&oacute;n [^abcd...]</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">TransitionExcludeRange. Representa la transici&oacute;n [^a-z]</span></li>
<li><span style="font-size: 13px; line-height: 1.5em;">TransitionRange. Representa la transici&oacute;n [a-z] y al mismo tiempo un selector 'a'. Para este segundo caso simplemente se establece que el inicio y final del rango es el mismo car&aacute;cter.</span></li>
</ul>
<p>&nbsp;</p>
<p>La clase para el aut&oacute;mata, <em>Automaton</em>, contendr&aacute; una referencia al primer estado, as&iacute; como la lista de transiciones usadas y la lista de estados. Mantener las dos listas anteriores viene muy bien a la hora de ejecutar el algoritmo que reducir&aacute; el AFND a un aut&oacute;mata determinista.</p>
<p>&nbsp;</p>
<h4>Generaci&oacute;n del aut&oacute;mata finito no determinista (AFND).</h4>
<p>&nbsp;</p>
<p>Un lenguaje regular puede ser analizado por un aut&oacute;mata finito no determinista (a partir de ahora, AFND) por lo que la siguiente fase del motor de regexp es generar este aut&oacute;mata.</p>
<p>Para generar un AFND a partir de una expresi&oacute;n regular, se puede seguir el <a href="http://es.wikipedia.org/wiki/Algoritmo_de_Thompson%20Criterios%20de%20Thompson">algoritmo de Thompson</a>. Este asocia cada expresi&oacute;n regular m&iacute;nima con un aut&oacute;mata finito no determinista.</p>
<p>&nbsp;</p>
<p>Veamos qu&eacute; AFND se genera por cada regexp m&iacute;nima:</p>
<p>&nbsp;</p>
<p>Para la expresi&oacute;n regular <em>a</em> (o cualquier selector m&iacute;nimo)</p>
<p>&nbsp;</p>
<p><img id="pbImage43765" src="/f/rexgen_afnd1.png" alt="" /></p>
<p>&nbsp;</p>
<p>Para una regexp con cuantificador '+', por ejemplo <em>a+</em></p>
<p>&nbsp;</p>
<p><img id="pbImage238704" src="/f/rexgen_afnd2.png" alt="" /></p>
<p>&nbsp;</p>
<p>Para la regexp R con cuantificador '*', por ejemplo <em>a*</em></p>
<p>&nbsp;</p>
<p><img id="pbImage910735" src="/f/rexgen_afnd3.png" alt="" /></p>
<p>&nbsp;</p>
<p>Para una regexp con cuantificador '?', por ejemplo <em>a?</em></p>
<p>&nbsp;</p>
<p><em><img id="pbImage729052" src="/f/rexgen_afnd4.png" alt="" /><br /></em></p>
<p><br />Para un regexp tipo 'R1|R2' como <em>abc|def</em></p>
<p>&nbsp;</p>
<p><img id="pbImage900796" style="border: 0px none;" src="/f/rexgen_afnd5.png" alt="" width="700" height="69" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Para una agrupaci&oacute;n (modificaci&oacute;n de precedencia) tipo <em>ab(c|d)ef</em></p>
<p>&nbsp;</p>
<p><em><img id="pbImage89175" style="border: 0px none;" src="/f/rexgen_afnd6.png" alt="" width="600" height="78" /><br /></em></p>
<p>&nbsp;</p>
<p>Para la regexp con varios selectores seguidos (concatenaci&oacute;n) como 'abcd'</p>
<p>&nbsp;</p>
<p><img id="pbImage616204" style="border: 0px none;" src="/f/rexgen_afnd7.png" alt="" width="600" height="28" /></p>
<p>&nbsp;</p>
<p>Los rangos siguen siendo selectores, por lo que los AFND generados son iguales a los de un s&oacute;lo car&aacute;cter. La diferencia fundamental es que para un rango tipo [a-z] no es &oacute;ptimo crear 26 transiciones, por lo que se ha creado un tipo de transici&oacute;n que representa rangos.<br /><br />Por ejemplo, la regexp [a-z]+ genera el siguiente AFND</p>
<p>&nbsp;</p>
<p><img id="pbImage935824" src="/f/rexgen_afnd8.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Para generar estos AFND se sigue un esquema parecido al analizador sint&aacute;ctico, pero esta vez se analiza el &aacute;rbol de nodos sint&aacute;cticos que se ha generado. Cada nodo o producci&oacute;n tendr&aacute; su correspondiente m&eacute;todo que genera el AFND m&iacute;nimo.<br /><br />Fij&eacute;monos ahora en el &aacute;rbol sint&aacute;ctico generado anteriormente. Comprobamos que por cada nodo tipo <em>regexp </em>hay una serie de <em>expresiones cuantificadas</em> en el primer nivel. Esto implica que para construir el AFND se ir&aacute;n analizando cada QUANTIFIED_EXPRESSION en el mismo nivel y por cada uno, analizar en profundidad su rama. A la vuelta de cada una de ellas, se guardar&aacute;n los estados generados en una cola. Al final, se iterar&aacute; sobre esta cola para ir concatenando todos los AFND.<br /><br />Los aut&oacute;matas que se van generando ser&aacute;n almacenados como un grafo de estados. Para representar esta estructura se usa la clase <em>StatePair</em></p>
<p>&nbsp;</p>
<pre>/**
&nbsp;* Almacena un par de estados. Esta estructura ser&aacute; &uacute;til para ir construyendo el
&nbsp;* grafo que representa el aut&oacute;mata.
&nbsp;*/
class StatePair {

&nbsp;&nbsp;&nbsp; private State firstState;
&nbsp;&nbsp;&nbsp; private State secondState;

&nbsp;&nbsp;&nbsp; public StatePair(State firstState, State secondState) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstState = firstState;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.secondState = secondState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public State getFirstState() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return firstState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void setFirstState(State firState) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstState = firState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public State getSecondState() {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return secondState;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public void setSecondState(State secondState) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.secondState = secondState;
&nbsp;&nbsp;&nbsp; }
}
</pre>
<p>&nbsp;</p>
<p>Basta con almacenar el estado inicial para comenzar la b&uacute;squeda en el grafo de estados, y el estado final para poder concatenar este grafo (o aut&oacute;mata) al siguiente que se genere.<br /><br />La clase encargada de construir el AFND es <em>AutomatonBuilder</em>. El m&eacute;todo <em>generateNFA(ASTNode node)</em> obtendr&aacute; el nodo ra&iacute;z del &aacute;rbol y lo enviar&aacute; al m&eacute;todo <em>faBuildRegexp</em>. Este m&eacute;todo analizar&aacute; el primer nivel desde el nodo enviado para ir almacenando las expresiones en una cola:<br /><br /></p>
<pre>private StatePair faBuildRegexp(ASTNode pNode) {

&nbsp;&nbsp; &nbsp;StatePair headStatePair = null;
&nbsp;&nbsp; &nbsp;// cola de aut&oacute;matas a concatenar
&nbsp;&nbsp; &nbsp;Queue&lt;StatePair&gt; statePairsQueue = new LinkedList&lt;StatePair&gt;();

&nbsp;&nbsp; &nbsp;for (ASTNode childNode : pNode.getChildren()) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (childNode.getType().equals(Token.QUANTIFIED_EXPR)) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StatePair newExpressionPair = faBuildQuantifiedExpression(childNode);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/* a&ntilde;adir subconjunto de estados del aut&oacute;mata a la cola para
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; * unir todos posteriormente. Esto respeta el orden de
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;* prioiridad: primero las expresiones y luego el OR
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*/
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;statePairsQueue.add(newExpressionPair);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; } else if (childNode.getType().equals(Token.REGEX)) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/* 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Si hemos llegado aqu&iacute;, es porque hay un OR. Seguimos el criterio de Thompson 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; para conectar los estados y cosntruir el AFND
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StatePair regexpPair = faBuildRegex(childNode, statePairsQueue);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// conectamos todos los estados anteriores, que forman r1
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StatePair orStatePair = null;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;headStatePair = statePairsQueue.poll();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;orStatePair = headStatePair;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (!statePairsQueue.isEmpty()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; StatePair newStatePair = statePairsQueue.poll();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; orStatePair.getSecondState().connect(createEmptyTransition(), 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newStatePair.getFirstState());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; orStatePair = newStatePair;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/*
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; * ahora r1 es un solo aut&oacute;mata que unimos al aut&oacute;mata del
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; * segundo operador del OR
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; */

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;State q0 = new State();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;State q1 = new State();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;q0.connect(createEmptyTransition(), headStatePair.getFirstState());

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;q0.connect(createEmptyTransition(), regexpPair.getFirstState());

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;regexpPair.getSecondState().connect(createEmptyTransition(), q1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;orStatePair.getSecondState().connect(createEmptyTransition(), q1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;StatePair pipeStatePair = new StatePair(q0, q1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;statePairsQueue.add(pipeStatePair);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;/*
&nbsp;&nbsp; &nbsp; * Se unen todos los subconjuntos de estados obtenidos a partir de los
&nbsp;&nbsp; &nbsp; * nodos sint&aacute;cticos analizados.
&nbsp;&nbsp; &nbsp; * 
&nbsp;&nbsp; &nbsp; * Estos son los nodos tipo &lt;qualified_expression&gt; que a&uacute;n hay que
&nbsp;&nbsp; &nbsp; * procesar.
&nbsp;&nbsp; &nbsp; */
&nbsp;&nbsp; &nbsp;headStatePair = statePairsQueue.poll();
&nbsp;&nbsp; &nbsp;StatePair tmpPair = headStatePair;

&nbsp;&nbsp; &nbsp;while (!statePairsQueue.isEmpty()) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; StatePair pair = statePairsQueue.poll();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; tmpPair.getSecondState().connect(createEmptyTransition(), pair.getFirstState());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; tmpPair = pair;
&nbsp;&nbsp; &nbsp;}

&nbsp;&nbsp; &nbsp;headStatePair.setSecondState(tmpPair.getSecondState());

&nbsp;&nbsp; &nbsp;return headStatePair;
}

</pre>
<p>Por cada QUANTIFIED_EXPRESSION se construir&aacute; el aut&oacute;mata que lo represente y se almacenar&aacute; en la cola.</p>
<p>&nbsp;</p>
<p>Llamando a <em>faBuildQuantifiedExpression</em>se ir&aacute; navegando en profundidad en la rama correspondiente del &aacute;rbol sint&aacute;ctico, llamando a su vez al m&eacute;todo adecuado por cada nodo del &aacute;rbol. Esto es exactamente la misa estrategia que se us&oacute; en el analizador sint&aacute;ctico.<br /><br />Por ejemplo, cuando llega un s&iacute;mbolo (como 'a') se ejecutar&aacute; el siguiente m&eacute;todo, que construir&aacute; el AFND m&iacute;nimo para un s&iacute;mbolo:</p>
<p>&nbsp;</p>
<pre>private StatePair faBuildChar(ASTNode pNode) {

&nbsp;&nbsp; &nbsp;char character = pNode.getValue().charAt(0);
&nbsp;&nbsp; &nbsp;char initChar;
&nbsp;&nbsp; &nbsp;char endChar;

&nbsp;&nbsp; &nbsp;if (character == '.') {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; initChar = ' ';
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; endChar = Character.MAX_VALUE;
&nbsp;&nbsp; &nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; initChar = endChar = character;
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;// crear la transicion tipo rango (de un car&aacute;cter)
&nbsp;&nbsp; &nbsp;Transition t = new TransitionRange(initChar, endChar);
&nbsp;&nbsp; &nbsp;// crear los estados final e incial
&nbsp;&nbsp; &nbsp;State init = new State();
&nbsp;&nbsp; &nbsp;State end = new State();
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;// conectarlos
&nbsp;&nbsp; &nbsp;init.connect(t, end);

&nbsp;&nbsp; &nbsp;return new StatePair(init, end);
}
</pre>
<p>&nbsp;</p>
<p>De esta forma ya hemos creado el AFND m&iacute;nimo para el selector 'a'. Ahora este AFND se retorna al m&eacute;todo que lo ha llamado para que a su vez lo a&ntilde;ada al que ha creado, y as&iacute; sucesivamente.</p>
<p>&nbsp;</p>
<p>Analizaremos el m&eacute;todo que genera una <em>&lt;quantified_expression&gt; </em>completa. Si nos fijamos en el nodo QUANTIFIED_EXPRESSION del &aacute;rbol sint&aacute;ctico de la regexp <em>ab+</em>:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;<img id="pbImage56430" src="/f/rexgen_ast2.png" alt="" /></p>
<p>&nbsp;</p>
<p>Vemos que si hay un cuantificador (en esta caso, '+'), se a&ntilde;ade como hermano del nodo de la expresi&oacute;n a cuantificar. Ese cuantificador afecta a toda la rama anterior.</p>
<p>&nbsp;</p>
<p>Lo siguiente es el c&oacute;digo que genera el AFND para una expresi&oacute;n cuantificada. Primero genera el AFND de la expresi&oacute;n en s&iacute; para luego conectar los estados correspondientes a los cuantificadores, siguiendo los criterios de Thompson.</p>
<p>&nbsp;</p>
<pre>private StatePair faBuildQuantifiedExpression(ASTNode quantifiedExpression) {

&nbsp;&nbsp; &nbsp;StatePair headStatePair = null;
&nbsp;&nbsp; &nbsp;StatePair expressionPair = null;

&nbsp;&nbsp; &nbsp;for (ASTNode child : quantifiedExpression.getChildren()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (child.getType() == Token.EXPRESSION) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatePair newExpressionPair = faBuildExpression(child);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (expressionPair != null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transition t = createEmptyTransition();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.getSecondState().connect(t, newExpressionPair.getFirstState());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;  expressionPair = newExpressionPair;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  } else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // el nodo es de tipo cuantificador
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (child.getValue().equals("+")) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Transition t = createEmptyTransition();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; expressionPair.getSecondState().connect(t, expressionPair.getFirstState());

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; } else if (child.getValue().equals("*")) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// conectar primero con ultimo con una transicion vacia
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transition t = createEmptyTransition();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.getSecondState().connect(t, expressionPair.getFirstState());

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// crear dos nuevos estados para '*'
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State q0 = new State();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; State q1 = new State();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q0.connect(createEmptyTransition(), expressionPair.getFirstState());

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.getSecondState().connect(createEmptyTransition(), q1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q0.connect(createEmptyTransition(), q1);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.setFirstState(q0);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.setSecondState(q1);
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } else { // tipo '?'
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressionPair.getFirstState().connect(createEmptyTransition(), expressionPair.getSecondState());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (headStatePair == null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headStatePair = expressionPair;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;return headStatePair;
}</pre>
<p>&nbsp;</p>
<p>Para la regexp anterior (<em>ab+</em>), el AFND resulta:</p>
<p>&nbsp;</p>
<p><img id="pbImage665253" src="/f/rexgen_afnd9.png" alt="" /></p>
<h3>&nbsp;</h3>
<h4>Generaci&oacute;n del aut&oacute;mata finito determinista (AFD)</h4>
<h3>&nbsp;</h3>
<p>Es posible ejecutar un AFND para verificar la expresi&oacute;n regular contra un texto, pero resulta bastante engorroso de codificar. Hay que mantener dos pilas e ir alternando en funci&oacute;n de los caracteres. <br /><br />Resulta mucho m&aacute;s r&aacute;pido y sencillo ejecutar un AFD; y precisamente aprovechamos el hecho de que todo AFND tiene un AFD equivalente (reconoce el mismo lenguaje regular)</p>
<p>&nbsp;</p>
<p>Por ello tenemos que convertir el AFND en AFD usando un algoritmo llamado <strong>Construcci&oacute;n subconjunto</strong><br /><br />Este algoritmo consiste en agrupar los estados del AFND que resultan de leer un mismo s&iacute;mbolo de entrada, adem&aacute;s de agrupar aquellos estados que se conectan entre s&iacute; con transiciones vac&iacute;as.<br /><br />El algoritmo usa tres operaciones b&aacute;sicas:<br /><br />Si Qn es cualquier estado del AFDN:</p>
<p>&nbsp;</p>
<p><strong>Cierre-epsilon(Qn)</strong>: Produce el conjunto de estados que se alcanzan desde el estado Qn usando la transici&oacute;n vac&iacute;a. Siempre incluye el propio estado del que parte.</p>
<p><br />Esta operaci&oacute;n permite obtener todos los estados que siempre son alcanzables partiendo de un estado determinado, de forma que pueden agruparse en uno sin problemas.<br /><br />Si Sn es un estado del AFD que agrupa a estados del AFND:<br /><br /><strong>Cierre-epsilon(An)</strong>: Produce el conjunto de estados que pueden ser alcanzados con transiciones vac&iacute;as desde cada uno de los estados agrupados. <br /><br /><strong>Movimiento(Sn, 'caracter')</strong>: Retorna aquellos estados del AFND que son alcanzables usando el car&aacute;cter especificado desde cada uno de los estados que agrupa Sn.</p>
<p>&nbsp;</p>
<p>Pseud&oacute;digo del algoritmo subconjunto:</p>
<p>&nbsp;</p>
<pre>1&nbsp;&nbsp; &nbsp;estadosAFD : list
2&nbsp;&nbsp; &nbsp;S = cierre-epsilon(estado_inicial(AFND))
3&nbsp;&nbsp; &nbsp;Mientras estados sin marcar en estadosAFD hacer
4&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;S = obtener_un_sin_marcar(estadosAFD)
5&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Por cada s=s&iacute;mbolo del lenguaje del aut&oacute;mata hacer
6&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SM = Move(S,s)
7&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;si SM no es vac&iacute;o
8&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SM = cierre-epsilon(SM)
9&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;si (SM no esta en estadosAFD) entonces
10&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;estadosAFD = estadosAFD UNION SM
11&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fin si
12&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;conectar SM con S con transici&oacute;n s
13&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fin si
14&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fin para
15&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;marcar(S);
16&nbsp;&nbsp; &nbsp;fin mientras</pre>
<p>&nbsp;</p>
<p>Finalmente <em>estadosAFD</em> ser&aacute; el conjunto de estados del AFD.<br /><br />Nos fijamos en la l&iacute;nea 5 del pseudoc&oacute;digo del algoritmo. Esta especifica que hay que realizar las operaciones de agrupaci&oacute;n por cada s&iacute;mbolo del lenguaje que reconoce el AFND. Realmente este lenguaje ya lo sabemos: es el conjunto de transiciones del AFND, de ah&iacute; que la clase <em>Automaton </em>almacene la una lista de todas las transiciones del aut&oacute;mata. Si no fuera as&iacute;, habr&iacute;a que probar con todo el conjunto de caracteres Unicode.</p>
<p>&nbsp;</p>
<p>Para este algoritmo se ha usado una clase auxiliar llamada SubSetState. Esta clase simplemente agrupa un Set de objetos State.</p>
<p>&nbsp;</p>
<p>El c&oacute;digo que realiza esta operaci&oacute;n est&aacute; tambien en la clase <em>AutomatonBuilder; </em>m&eacute;todo <em>generateDFA</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre>public Automaton generateDFA(Automaton pNDAutomaton) {

&nbsp;&nbsp; &nbsp;List&lt;SubSetState&gt; estadosAFD = new LinkedList&lt;SubSetState&gt;();
&nbsp;&nbsp; &nbsp;// calcular cierre-epsilon del estado inicial
&nbsp;&nbsp; &nbsp;SubSetState S1 = epsilonClosure(pNDAutomaton.getInitialState());
&nbsp;&nbsp; &nbsp;S1.setInitial(true);
&nbsp;&nbsp; &nbsp;estadosAFD.add(S1);</pre>
<pre>&nbsp;&nbsp; &nbsp;// obetener esatdo no marcado
&nbsp;&nbsp; &nbsp;SubSetState subSetState = selectState(estadosAFD);

&nbsp;&nbsp; &nbsp;// mientras haya estados no procesados o marcados
&nbsp;&nbsp; &nbsp;while (subSetState != null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // por cada s&iacute;mbolo 'a' perteneciente al lenguaje
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  for (Transition t : pNDAutomaton.getAlphabet()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(t instanceof TransitionEmpty)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calcular a que estados se va con esta transici&oacute;n desde el
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// subonjutno de estados
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubSetState moveState = epsilonMove(pNDAutomaton, subSetState, t);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!moveState.isEmpty()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubSetState moCloseState = epsilonClosure(moveState);

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// comprueba si no existe ya este estado agrupado.
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubSetState euqlState = findState(estadosAFD, moCloseState);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (euqlState == null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;estadosAFD.add(moCloseState);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moCloseState = euqlState;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  Transition afdTransition;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;afdTransition = (Transition) t.clone();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (CloneNotSupportedException e) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; throw new RuntimeException("Fallo en la copia de una transici&oacute;n.");
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subSetState.getState().connect(afdTransition, moCloseState.getState());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; subSetState.setMark(true);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // siguiente estado sin marcar
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; subSetState = selectState(estadosAFD);
&nbsp;&nbsp;  }
&nbsp;&nbsp; &nbsp;// construir aut&oacute;mata determinista con los nuevos estados interconectados
&nbsp;&nbsp; &nbsp;Automaton dfa = new Automaton(S1.getState());
&nbsp;&nbsp; &nbsp;return dfa;
}
</pre>
<p>El AFD resultante para la regexp anterior (<em>ab+</em>) es:</p>
<p>&nbsp; <img id="pbImage268799" src="/f/rexgen_afd2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>Ejecuci&oacute;n de la regexp</h3>
<h3>&nbsp;</h3>
<p>El &uacute;ltimo paso de la compilaci&oacute;n es crear el objeto <em>Regex </em>y asignarle el objeto <em>Automaton, </em>que a su vez contiene el AFD generado. De esto se encarga el m&eacute;todo compile de la clase <em>RegexEngine</em></p>
<p>&nbsp;</p>
<pre>public static Regex compile(String regexExpr) throws RegexException {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LexicalAnalyzer lexicalAnalyzer = new LexicalAnalyzer(regexExpr);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Parser syntaxAnalyzer = new Parser(lexicalAnalyzer);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ASTNode syntaxNodeTree = syntaxAnalyzer.analyze();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LOGGER.debug("Arbol sint&aacute;ctico:\n graph g {\n{}\n};\n", syntaxNodeTree.toString());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Automaton nfa = AutomatonBuilder.generateFromAST(syntaxNodeTree);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LOGGER.debug("Aut&oacute;mata NO determinista:\n digraph afnd {\n{}\n};\n", nfa.toString());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Automaton dfa = AutomatonBuilder.generateDFAFromNFA(nfa);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;LOGGER.debug("Aut&oacute;mata Determinista:\n digraph afnd {\n{}\n};\n", dfa.toString());
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return new Regex(dfa);
}</pre>
<p>&nbsp;</p>
<p>Este m&eacute;todo cubre todas las fases de compilaci&oacute;n que se han explicado.<br /><br />Ahora es el turno de ejecutar la regexp contra un texto. Esta tarea la lleva a cabo el propio objeto <em>Regex </em>en el m&eacute;todo <em>match</em>:</p>
<p>&nbsp;</p>
<pre>public boolean match(char[] buffer, RegexMatchResult regexMatcher) {

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean stop = false;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean match = false;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// indice que apunta al comienzo de la coincidencia.
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int matchStartPosition = -1;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// posicion actual
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int position = 0;

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (regexMatcher != null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position = regexMatcher.getPosition();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// comienzo del automata
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;State currentState = finiteAutomaton.getInitialState();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// el aut&oacute;mata siempre quiere consumir caracteres
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (currentState.hasTransitions() &amp;&amp; (position &lt; buffer.length) &amp;&amp; !stop) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;char c = buffer[position];
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// enfrentar el car&aacute;cter con la regex
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Transition transition = matchTransition((char) c, currentState);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (transition == null) { // no hay coincidencia
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// si de todas formas estamos en un estado final, entonces hay match
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (currentState.isEnd()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;match = true;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;stop = true;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (matchStartPosition == -1) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;matchStartPosition = position;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// reiniciar automata
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentState = finiteAutomaton.getInitialState();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position++;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// no hay posicion de comienzo de region
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;matchStartPosition = -1;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} else {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// coincide, avanzamos estado
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;currentState = transition.getNextState();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// registramos la posicion de comienzo de la coincidencia. La regex se cumplir&aacute; si el estado es de aceptacion
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;match = currentState.isEnd();

&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (matchStartPosition == -1) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;matchStartPosition = position;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;position++;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (match) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (regexMatcher != null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;regexMatcher.setMatchStartPosition(matchStartPosition);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;regexMatcher.setMatchLength(position - matchStartPosition);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return match;
&nbsp;&nbsp; &nbsp;}

&nbsp;private Transition matchTransition(char c, State pState) {
&nbsp;   Iterable&lt;Transition&gt; transitionList = pState.getTransitions();
&nbsp;&nbsp;  if (transitionList != null) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; for (Transition t : pState.getTransitions()) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (t.match(c)) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return t;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; }
&nbsp;&nbsp;  }
&nbsp;&nbsp;  return null;

}
&nbsp;</pre>
<h3>Consideraciones finales.</h3>
<p>&nbsp;</p>
<p>Un paso que no hemos implementado es la minimizaci&oacute;n del AFD, pero esta operaci&oacute;n no siempre puede ser realizada.<br /><br />Existen formas m&aacute;s sencillas de almacenar los aut&oacute;matas, como usar matrices de adyacencia en lugar de listas. Esto implica una ganancia en el rendimiento de ejecuci&oacute;n del aut&oacute;mata pero a cambio de un mayor uso de memoria.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
